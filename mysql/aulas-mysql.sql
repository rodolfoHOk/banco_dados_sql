/* MODELAGEM BASICA

ENTIDADE = TABELA
ATRIBUTO = CAMPOS */

CLIENTE

NOME - CARACTER(30)
CPF - NUMERICO(11)
EMAIL - CARACTER(30)
TELEFONE - CARACTER(30)
ENDERECO - CARACTER(100)
SEXO - CARACTER(1)

/* PROCESSO DE MODELAGEM */

/* FASE 01 E FASE 02 - AD (ADMINSTRADOS DE DADOS) */
MODELAGEM CONCEITUAL - RASCUNHO
MODELAGEM LÓGICA - QUALQUER PROGRAMA DE MODELAGEM

/* FASE 03 - DBA ou AD */
MODELAGEM FÍSICA - SCRIPTS DE BANCO DE DADOS

/* INICIANDO A MODELAGEM FÍSICA */

/* CRIANDO O BANCO DE DADOS */

CREATE DATABASE PROJETO;

/* CONECTANDO-SE AO BANCO */

USE PROJETO;

/* CRIANDO A TABELA CLIENTES */

CREATE TABLE CLIENTE(
	NOME VARCHAR(30),
	SEXO CHAR(1),
	EMAIL VARCHAR(30),
	ENDERECO VARCHAR(100),
	TELEFONE VARCHAR(30),
	CPF INT(11)
);

/* VERIFICANDO AS TABELAS DO BANCO */

SHOW TABLES;

/* DESCOBRINDO COMO É A ESTRUTURA DE UMA TABELA */

DESC CLIENTE;

/* Sintaxe básica de inserção - INSERT INTO NomeTabela... */

/* FORMA 01 - OMITINDO AS COLUNAS */
INSERT INTO CLIENTE
VALUES('JOAO', 'M', 'joao@email.com', 'MAIA LACERDA - ESTACIO - RIO DE JANEIRO - RJ', 988638273, '22923110');

INSERT INTO CLIENTE
VALUES('CELIA', 'F', 'celia@email.com', 'RIACHUELO - CENTRO - RIO DE JANEIRO - RJ', 541521456, '25078869');

INSERT INTO CLIENTE 
VALUES('JORGE', 'M', NULL, 'BOM RETIRO - PATO DE MINAS -MG', 885755896, '58748895');

/* FORMA 02 - COLOCANDO AS COLUNAS */
INSERT INTO CLIENTE(NOME, SEXO, ENDERECO, TELEFONE, CPF)
VALUES('LILIAN','F','SENADOR SOARES - TIJUCA - RIO DE JANEIRO - RJ','947785696',887774856);

/* FORMA 03 - COMPACTO - SOMENTE MYSQL*/
INSERT INTO CLIENTE 
VALUES('ANA','F','ana@globo.com','PRES ANTONIO CARLOS - CENTRO - SAO PAULO - SP', 85549862,'548556985'),
('CARLA','F','carla@terati.com.br','SAMUEL SILVA - CENTRO - BELO HORIZONTE - MG', 7745828, '66587458');

/* O COMANDO SELECT 
seleção, *projeção, junção
*/

SELECT NOW();

SELECT 'FELIPE MAFRA';

SELECT 'BANCO DE DADOS';

/* ALIAS */

SELECT NOW() AS 'DATA_HORA';

SELECT NOW() AS 'DATA_HORA', 'FELIPE MAFRA' AS 'PROFESSOR';


/* ALIAS DE COLUMAS */

SELECT NOME, SEXO, EMAIL FROM CLIENTE;

SELECT NOME AS 'CLIENTE', SEXO, EMAIL FROM CLIENTE;

SELECT NOME, SEXO, EMAIL, ENDERECO FROM CLIENTE;

SELECT EMAIL, SEXO, ENDERECO, NOME FROM CLIENTE;

SELECT EMAIL, SEXO, ENDERECO, NOME, NOW() AS 'DATA_HORA' FROM CLIENTE;

/* APENAS PARA FINS ACADEMICOS */

SELECT * FROM CLIENTE;

/* FILTRANDO DADOS COM WHERE E LIKE
OBS:
PARA PROJEÇÃO TEMOS COMANDO SELECT
PARA SELEÇÃO TEMOS COMANDO WHERE
*/

SELECT NOME, TELEFONE FROM CLIENTE;

/* FILTRANDO */

SELECT NOME, SEXO FROM CLIENTE
WHERE SEXO = 'M';

SELECT NOME, ENDERECO FROM CLIENTE
WHERE SEXO = 'F';

SELECT NOME, SEXO FROM CLIENTE
WHERE ENDERECO = 'RJ'; (ERRO)

/* USANDO O LIKE */

SELECT NOME, SEXO FROM CLIENTE
WHERE ENDERECO LIKE 'RJ'; (ERRO)

/* CARACTER CORINGA % -> QUALQUER COISA */

SELECT NOME, SEXO FROM CLIENTE
WHERE ENDERECO LIKE '%RJ';

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE ENDERECO LIKE '%RJ';

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE ENDERECO LIKE 'SENADOR SOARES%';

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE ENDERECO LIKE '%CENTRO%';


/* exercicio1-mysql.sql */


/* VERIFICANDO BANCOS */
SHOW DATABASES;

/* VERIFICAR BANCO ATUAL */
STATUS;

/* OPERADORES LÓGICOS */

/* OR - OU */

SHOW DATABASES;
USE PROJETO;
SELECT * FROM CLIENTE;

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE SEXO = 'M' OR ENDERECO LIKE '%RJ';

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE SEXO = 'F' OR ENDERECO LIKE '%ESTACIO%';

/* AND - E */

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE SEXO = 'M' AND ENDERECO LIKE '%RJ';

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE SEXO = 'F' AND ENDERECO LIKE '%ESTACIO%';

/* COUNT(*), GROUP BY, PERFORMANCE COM OPERADORES LÓGICOS */

/* CONTANDO OS REGISTROS DE UMA TABELA */

SELECT COUNT(*) FROM CLIENTE;

SELECT COUNT(*) AS "Quantidade de registros da tabela cliente" FROM CLIENTE;

/* OPERADOR GROUP BY */

SELECT SEXO, COUNT(*) FROM CLIENTE; (erro)

SELECT SEXO, COUNT(*) FROM CLIENTE
GROUP BY SEXO;

/* PERFORMANCE COM OPERADORES LÓGICOS */

/* SUPONHAMOS QUE TENHAMOS 1 MILHAO DE REGISTROS NA TABELA

PARA CONTAR
SELECT COUNT(*) FROM CLIENTE;

SELECT SEXO, COUNT(*) FROM CLIENTE
GROUP BY SEXO;

SELECT CIDADE, COUNT(*) FROM CLIENTE
GROUP BY CIDADE;

CONDICAO
SEXO = F
CIDADE = RIO DE JANEIRO

SITUACAO - TRATANDO COM OU / OR
70% MULHERES = SEXO = F
30% MORA NO RIO DE JANEIRO

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE SEXO = 'M'
OR CIDADE = 'RIO DE JANEIRO';

* COLOCAMOS SEXO PRIMEIRO POIS TEM MAIS REGISTROS VERDADEIROS NESTA SITUACAO DE OU(OR)
EXIGINDO MENOS PROCESSAMENTO POIS TEM A PRIMEIRA VERDADEIRA A RESPOSTA JÁ RETORNA VERDADEIRA A RESPOSTA
SEM CHECAR A SEGUNDA OPCAO;

SITUACAO - TRATANDO COM E / AND
70% MULHERES = SEXO = F
30% MORA NO RIO DE JANEIRO

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE CIDADE = 'RIO DE JANEIRO'
AND SEXO = 'F';

* COLOCAMOS CIDADE PRIMEIRO POIS TEM MENOS REGISTROS VERDADEIROS NESTA SITUACAO DE E(AND)
EXIGINDO MENOS PROCESSAMENTO POIS SENDO A PRIMEIRA FALSA A RESPOSTA JÁ DESCARTA O REGISTRO
NÃO NECESSITANDO CONSULTAR A SEGUNDA OPÇÃO;
*/


/* exercicio2-mysql.sql */


/* FILTRANDO VALORES NULOS */

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE EMAIL = NULL; --(NAO FUNCIONA -> EMPTY SET)

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE EMAIL IS NULL;

SELECT NOME, SEXO, ENDERECO FROM CLIENTE
WHERE EMAIL IS NOT NULL;

-- IS OU IS NOT NULL MUITO USADO EM JOIN QUE VEREMOS MAIS TARDE

/* UTILIZANDO A CLAUSULA "UPDATE" PARA ATUALIZAR VALORES */

SELECT NOME EMAIL FROM CLIENTE;

UPDATE CLIENTE
SET EMAIL = 'lilian@hotmail.com'; -- NAO FACA ISSO TODOS OS EMAIL FICARAM IGUAL A ESTE AI SOMENTE FAZENDO "COMMIT" OU "ROLLBACK" OU "RESTAURAR O BACKUP"

SELECT * FROM CLIENTE 
WHERE NOME = 'LILIAN'; -- SELECIONA SOMENTE LILIAN

UPDATE CLIENTE
SET EMAIL = 'lilian@hotmail.com'
WHERE NOME = 'LILIAN'; -- CORRETO

UPDATE CLIENTE
SET EMAIL = 'jorge@ig.com.br'
WHERE NOME = 'JORGE';

/* DELETANDO REGISTROS COM A CLAUSULA "DELETE" */

DELETE FROM CLIENTE; --- NAO FACA ISSO TODOS REGISTROS SERAO APAGADOS

-- USANDO UM METODO MAIS SEGURO:
SELECT COUNT(*) FROM CLIENTE;
--- TOTAL 6

SELECT * FROM CLIENTE
WHERE NOME = 'ANA';
--- CONFIRMANDO DADOS A SER DELETADO TEM 1 ANA, PODE SER ASSIM MAS...

SELECT COUNT(*) FROM CLIENTE
WHERE NOME = 'ANA'; --- DESTE MODO É MELHOR SE UM BANCO DE DADOS FOR GRANDE.
--- TOTAL A SER DELETADO 1: TEMOS UM CLIENTE COM NOME ANA

DELETE FROM CLIENTE
WHERE NOME = 'ANA'; --- SÓ ENTÃO DELETAMOS SOMENTE COM NOMES ANA

SELECT COUNT(*) FROM CLIENTE; --- CONFIRMANDO A DELEÇÃO
--- TOTAL 5 APÓS DELECAO

--- OBS: PARA NÚMEROS GRANDES PODEMOS FAZER ASSIM:
SELECT 6 - 1;

SELECT * FROM CLIENTE;
INSERT INTO CLIENTE VALUES('CARLA','F','c.lopes@uol.com','RUA COPPER LEAF - WILLIAMBURG - KITCHENER','4575-0048',45638854);

DELETE FROM CLIENTE
WHERE NOME = 'CARLA'; -- OS DOIS REGISTRO SERAO DELETADOS SE FIZERMOS ISSO

DELETE FROM CLIENTE
WHERE NOME = 'CARLA'
OR EMAIL = 'lilian@hotmail.com'; -- ACHO QUE É ASSIM NÃO ESTOU SEGURO

SELECT * FROM CLIENTE
WHERE NOME = 'CARLA'
OR EMAIL = 'lilian@hotmail.com'; -- ENTÃO TESTAMOS ASSIM ANTES, E ESTÁ ERRADO!

SELECT * FROM CLIENTE
WHERE NOME = 'CARLA'
AND EMAIL = 'carla@terati.com.br'; -- TESTANDO NOVAMENTE COM AS MODIFICACOES

DELETE FROM CLIENTE
WHERE NOME = 'CARLA'
AND EMAIL = 'carla@terati.com.br'; -- DELETANDO CORRETAMENTE

SELECT * FROM CLIENTE; -- CONFIRMANDO DELEÇÃO

/* INICIANDO MODELAGEM */

/* ENTRANDO COM MAIS TELEFONES */

UPDATE CLIENTE
SET TELEFONE = '97865434'
WHERE NOME = 'JOAO';

SELECT * FROM CLIENTES;

UPDATE CLIENTE
SET TELEFONE = '22923110 - 97865434'
WHERE NOME = 'JOAO';

SELECT SEXO, COUNT(*) FROM CLIENTE
GROUP BY SEXO;

SELECT ENDERECO, COUNT(*) FROM CLIENTE
GROUP BY ENDERECO;

INSERT INTO CLIENTE VALUES('CARLA','F','c.lopes@uol.com','RUA COPPER LEAF - WILLIAMBURG - KITCHENER','9301-7585',45638854);

SELECT SEXO, COUNT(*) AS QTD FROM CLIENTE
GROUP BY SEXO;

/* PRIMEIRA FORMA NORMAL */

/* SÃO TRÊS REGRAS NA PRIMEIRA FORMA NORMAL

1 - TODO CAMPO VETORIZADO SE TORNARÁ OUTRA TABELA.

[AMARELO, AZUL, LARANJA, VERDE] -> VETOR DE CORES
[KA, FIESTA, UNO, CIVIC] -> VETOR DE CARROS

2 - TODO CAMPO MULTIVALORADO SE TORNARÁ OUTRA TABELA.

MULTIVALORADO QUANDO CAMPO FOR DIVISÍVEL

3 - TODA TABELA NECESSITA DE PELO MENOS UM CAMPO QUE IDENFIFIQUE TODO O REGISTRO COMO SENDO ÚNICO.

ISSO É O QUE CHAMANOS DE CHAVE PRIMÁRIA OU PRIMARY KEY

*/

/* OBRIGATORIEDADE E CARDINALIDADE */

/*
1° ALGORITIMO - OBRIGATORIEDADE 
0 -> NÃO OBRIGATÓRIO
1 -> OBRIGATÓRIO
2° ALGORITIMO - CARDINALIDADE
1 -> UM SÓ
N -> MAIS DE UM
*/

/* CRIANDO NOVO BANCO COM A PRIMEIRA FORMA NORMAL */

CREATE DATABASE COMERCIO;

SHOW DATABASES;

USE COMERCIO;

DROP TABLE CLIENTE; -- > APAGA A TABELA CLIENTE

CREATE TABLE CLIENTE(
	IDCLIENTE INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30) NOT NULL,
	SEXO ENUM('M','F') NOT NULL,
	EMAIL VARCHAR(50) UNIQUE,
	CPF VARCHAR(15) UNIQUE
);

SHOW TABLES;

/* ENDERECO - OBRIGATORIO E CADASTRO DE SOMENTE UM
TELEFONE - NAO OBRIGATORIO E CADASTRO DE MAIS DE UM */

/* FOREIGN KEY (FK) */
/* CHAVE ESTRANGEIRA É A PRIMARY KEY DE UMA TABELA
QUE VAI ATÉ A OUTRA TABELA 	PARA FAZER REFERENCIA ENTRE
REGISTROS */

/* EM RELACIONAMENTO 1X1 A CHAVE ESTRANGEIRA FICA NA TABELA MAIS FRACA */

/* EM RELACIONAMENTO 1XN A CHAVE ESTRANGEIRA FICARÁ SEMPRE NA CARDINALIDADE N */

CREATE TABLE ENDERECO(
	IDENDERECO INT PRIMARY KEY AUTO_INCREMENT,
	RUA VARCHAR(30) NOT NULL,
	BAIRRO VARCHAR(30) NOT NULL,
	CIDADE VARCHAR(30) NOT NULL,
	ESTADO CHAR(2) NOT NULL,
	ID_CLIENTE INT UNIQUE,
	FOREIGN KEY(ID_CLIENTE)
	REFERENCES CLIENTE(IDCLIENTE)
);

CREATE TABLE TELEFONE(
	IDTELEFONE INT PRIMARY KEY AUTO_INCREMENT,
	TIPO ENUM('RES','COM','CEL') NOT NULL,
	NUMERO VARCHAR(15) NOT NULL,
	ID_CLIENTE INT,
	FOREIGN KEY(ID_CLIENTE)
	REFERENCES CLIENTE(IDCLIENTE)
);

INSERT INTO CLIENTE VALUES(NULL,'JOAO','M','joao@ig.com','76567587887');

INSERT INTO CLIENTE VALUES(NULL,'CARLOS','M','carlos@ig.com','5464553466');
INSERT INTO CLIENTE VALUES(NULL,'ANA','F','ana@ig.com','456545678');
INSERT INTO CLIENTE VALUES(NULL,'CLARA','F',NULL,'5687766856');
INSERT INTO CLIENTE VALUES(NULL,'JORGE','M','jorge@ig.com','8756547688');
INSERT INTO CLIENTE VALUES(NULL,'CELIA','F','celia@ig.com','5767876889');

+-----------+--------+------+---------------+-------------+
| IDCLIENTE | NOME   | SEXO | EMAIL         | CPF         |
+-----------+--------+------+---------------+-------------+
|         1 | JOAO   | M    | joao@ig.com   | 76567587887 |
|         2 | CARLOS | M    | carlos@ig.com | 5464553466  |
|         3 | ANA    | F    | ana@ig.com    | 456545678   |
|         4 | CLARA  | F    | NULL          | 5687766856  |
|         5 | JORGE  | M    | jorge@ig.com  | 8756547688  |
|         6 | CELIA  | F    | celia@ig.com  | 5767876889  |
+-----------+--------+------+---------------+-------------+

SELECT * FROM CLIENTE;

DESC ENDERECO;

INSERT INTO ENDERECO VALUES(NULL,'RUA ANTONIO SA','CENTRO','B. HORIZONTE','MG',45);
-- ERRO NO BANCO CONSTRAINT FAILS

INSERT INTO ENDERECO VALUES(NULL,'RUA ANTONIO SA','CENTRO','B. HORIZONTE','MG',4);
-- OK

INSERT INTO ENDERECO VALUES(NULL,'RUA CAPITAO HERMES','CENTRO','RIO DE JANEIRO','RJ',1);
INSERT INTO ENDERECO VALUES(NULL,'RUA PRES VARGAS','JARDINS','SAO PAULO','SP',3);
INSERT INTO ENDERECO VALUES(NULL,'RUA ALFANDEGA','ESTACIO','RIO DE JANEIRO','RJ',2);
INSERT INTO ENDERECO VALUES(NULL,'RUA DO OUVIDOR','FLAMENGO','RIO DE JANEIRO','RJ',6);
INSERT INTO ENDERECO VALUES(NULL,'RUA URUGUAIANA','CENTRO','VITORIA','ES',5);

SELECT * FROM ENDERECO;

INSERT INTO ENDERECO VALUES(NULL,'RUA ALFANDEGA','CENTRO','SAO PAULO','SP',5);
--ERRO ENTRADA DUPLICADA

DESC TELEFONE;

INSERT INTO TELEFONE VALUES(NULL,'CEL','78458743',5);

INSERT INTO TELEFONE VALUES(NULL,'RES','56576876',5);
INSERT INTO TELEFONE VALUES(NULL,'CEL','87866896',1);
INSERT INTO TELEFONE VALUES(NULL,'COM','54768899',2);
INSERT INTO TELEFONE VALUES(NULL,'RES','99667587',1);
INSERT INTO TELEFONE VALUES(NULL,'CEL','78989765',3);
INSERT INTO TELEFONE VALUES(NULL,'CEL','99766676',3);
INSERT INTO TELEFONE VALUES(NULL,'COM','66687899',1);
INSERT INTO TELEFONE VALUES(NULL,'RES','89986668',5);
INSERT INTO TELEFONE VALUES(NULL,'CEL','88687909',2);

/* SELECAO, PROJECAO E JUNCAO */

/* PROJECAO -> É TUDO QUE VOCE QUER VER NA TELA */

SELECT NOW();

SELECT 2 + 2 AS SOMA;

SELECT 2 + 2 AS SOMA, NOME, NOW() FROM CLIENTE;

/* SELEÇÃO -> É UM SUBCONJUNTO DO CONJUNTO TOTAL DE REGISTROS DE UMA TABELA
A CLAUSULA DE SELECAO É O WHERE */

SELECT NOME, SEXO, EMAIL -- PROJECAO
FROM CLIENTE -- ORIGEN
WHERE SEXO = 'F'; -- SELECAO

SELECT NUMERO -- PROJECAO
FROM TELEFONE -- ORIGEN
WHERE TIPO = 'CEL'; -- SELECAO

/* JUNCAO -> JOIN */

SELECT NOME, EMAIL, IDCLIENTE
FROM CLIENTE;

SELECT ID_CLIENTE, BAIRRO, CIDADE
FROM ENDERECO;

+--------+---------------+-----------+
| NOME   | EMAIL         | IDCLIENTE |
+--------+---------------+-----------+
| JOAO   | joao@ig.com   |         1 |
| CARLOS | carlos@ig.com |         2 |
| ANA    | ana@ig.com    |         3 |
| CLARA  | NULL          |         4 |
| JORGE  | jorge@ig.com  |         5 |
| CELIA  | celia@ig.com  |         6 |
+--------+---------------+-----------+

+------------+----------+----------------+
| ID_CLIENTE | BAIRRO   | CIDADE         |
+------------+----------+----------------+
|          4 | CENTRO   | B. HORIZONTE   |
|          1 | CENTRO   | RIO DE JANEIRO |
|          3 | JARDINS  | SAO PAULO      |
|          2 | ESTACIO  | RIO DE JANEIRO |
|          6 | FLAMENGO | RIO DE JANEIRO |
|          5 | CENTRO   | VITORIA        |
+------------+----------+----------------+

/* NOME, SEXO, BAIRRO, CIDADE */

SELECT NOME, SEXO, BAIRRO, CIDADE -- PROJECAO
FROM CLIENTE, ENDERECO -- ORIGEN
WHERE IDCLIENTE = ID_CLIENTE; -- JUNCAO
-- FUNCIONA MAIS NÃO O IDEAL
+--------+------+----------+----------------+
| NOME   | SEXO | BAIRRO   | CIDADE         |
+--------+------+----------+----------------+
| JOAO   | M    | CENTRO   | RIO DE JANEIRO |
| CARLOS | M    | ESTACIO  | RIO DE JANEIRO |
| ANA    | F    | JARDINS  | SAO PAULO      |
| CLARA  | F    | CENTRO   | B. HORIZONTE   |
| JORGE  | M    | CENTRO   | VITORIA        |
| CELIA  | F    | FLAMENGO | RIO DE JANEIRO |
+--------+------+----------+----------------+

/* WHERE -> SELECAO */

SELECT NOME, SEXO, BAIRRO, CIDADE
FROM CLIENTE, ENDERECO
WHERE IDCLIENTE = ID_CLIENTE
AND SEXO = 'F';
-- TAMBEM FUNCIONA CONTINUA NAO SENDO IDEAL
+-------+------+----------+----------------+
| NOME  | SEXO | BAIRRO   | CIDADE         |
+-------+------+----------+----------------+
| ANA   | F    | JARDINS  | SAO PAULO      |
| CLARA | F    | CENTRO   | B. HORIZONTE   |
| CELIA | F    | FLAMENGO | RIO DE JANEIRO |
+-------+------+----------+----------------+

/*
WHERE IDCLIENTE = ID_CLIENTE -> SEMPRE VERDADE AI ENTRA O JOIN
AND SEXO = 'F'; -> TABELA VERDADE
*/

SELECT NOME, SEXO, BAIRRO, CIDADE
FROM CLIENTE
INNER JOIN ENDERECO
ON IDCLIENTE = ID_CLIENTE;
+--------+------+----------+----------------+
| NOME   | SEXO | BAIRRO   | CIDADE         |
+--------+------+----------+----------------+
| JOAO   | M    | CENTRO   | RIO DE JANEIRO |
| CARLOS | M    | ESTACIO  | RIO DE JANEIRO |
| ANA    | F    | JARDINS  | SAO PAULO      |
| CLARA  | F    | CENTRO   | B. HORIZONTE   |
| JORGE  | M    | CENTRO   | VITORIA        |
| CELIA  | F    | FLAMENGO | RIO DE JANEIRO |
+--------+------+----------+----------------+

SELECT NOME, SEXO, BAIRRO, CIDADE -- PROJECAO
FROM CLIENTE -- ORIGEN
	INNER JOIN ENDERECO -- JUNCAO
	ON IDCLIENTE = ID_CLIENTE
WHERE SEXO = 'F'; -- SELECAO
+-------+------+----------+----------------+
| NOME  | SEXO | BAIRRO   | CIDADE         |
+-------+------+----------+----------------+
| ANA   | F    | JARDINS  | SAO PAULO      |
| CLARA | F    | CENTRO   | B. HORIZONTE   |
| CELIA | F    | FLAMENGO | RIO DE JANEIRO |
+-------+------+----------+----------------+

/* NOME, SEXO, EMAIL, TIPO, NUMERO */
SELECT NOME, SEXO, EMAIL, TIPO, NUMERO
FROM CLIENTE
INNER JOIN TELEFONE
ON IDCLIENTE = ID_CLIENTE;

/* NOME, SEXO, BAIRRO, CIDADE, TIPO, NUMERO */
SELECT NOME, SEXO, BAIRRO, CIDADE, TIPO, NUMERO
FROM CLIENTE
INNER JOIN ENDERECO
ON IDCLIENTE = ENDERECO.ID_CLIENTE -- ITERANDO POR CAUSA ABIGUIDADE
INNER JOIN TELEFONE
ON IDCLIENTE = TELEFONE.ID_CLIENTE; -- ITERANDO POR CAUSA ABIGUIDADE
INNER JOIN TELEFONE
-- FUNCIONA MAIS NAO É O MELHOR
+--------+------+---------+----------------+------+----------+
| NOME   | SEXO | BAIRRO  | CIDADE         | TIPO | NUMERO   |
+--------+------+---------+----------------+------+----------+
| JOAO   | M    | CENTRO  | RIO DE JANEIRO | CEL  | 87866896 |
| JOAO   | M    | CENTRO  | RIO DE JANEIRO | RES  | 99667587 |
| JOAO   | M    | CENTRO  | RIO DE JANEIRO | COM  | 66687899 |
| CARLOS | M    | ESTACIO | RIO DE JANEIRO | COM  | 54768899 |
| CARLOS | M    | ESTACIO | RIO DE JANEIRO | CEL  | 88687909 |
| ANA    | F    | JARDINS | SAO PAULO      | CEL  | 78989765 |
| ANA    | F    | JARDINS | SAO PAULO      | CEL  | 99766676 |
| JORGE  | M    | CENTRO  | VITORIA        | CEL  | 78458743 |
| JORGE  | M    | CENTRO  | VITORIA        | RES  | 56576876 |
| JORGE  | M    | CENTRO  | VITORIA        | RES  | 89986668 |
+--------+------+---------+----------------+------+----------+

SELECT CLIENTE.NOME, CLIENTE.SEXO, ENDERECO.BAIRRO, ENDERECO.CIDADE, TELEFONE.TIPO, TELEFONE.NUMERO -- PONTEIRAMENTO
FROM CLIENTE
INNER JOIN ENDERECO
ON CLIENTE.IDCLIENTE = ENDERECO.ID_CLIENTE
INNER JOIN TELEFONE
ON CLIENTE.IDCLIENTE = TELEFONE.ID_CLIENTE;
-- MESMO RESULTADO ACIMA MELHORA PERFORMANCE POR CAUSA DO PONTEIRAMENTO

SELECT C.NOME, C.SEXO, E.BAIRRO, E.CIDADE, T.TIPO, T.NUMERO -- PONTEIRAMENTO
FROM CLIENTE C
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE 
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE;
-- MESMO RESULTADO TAMBEM POREM USANDO APELIDOS; TAMBEM AUMENTA A PERFORMANCE

/* 

	DML - DATA MANIPULATION LANGUAGE
	DDL - DATA DEFINITION LANGUAGE
	DCL - DATA CONTROL LANGUAGE
	TCL - TRANSACTION CONTROL LANGUAGE

/*

/* COMANDOS DML */

/* INSERT */

INSERT INTO CLIENTE VALUES(NULL,'PAULA','M',NULL,'77437493'); -- INSERT DML

INSERT INTO ENDERECO VALUES(NULL,'RUA JOAQUIM SILVA','ALVORADA','NITEROI','RJ');
-- ERRO

DESC ENDERECO; -- ENQUECEMOS O ID_CLIENTE;

SELECT * FROM CLIENTE; -- ID DA PAULA É 7 -- TAMBEM DML

INSERT INTO ENDERECO VALUES(NULL,'RUA JOAQUIM SILVA','ALVORADA','NITEROI','RJ',7);

/* FILTROS */

SELECT * FROM CLIENTE
WHERE SEXO = 'M';

/* UPDATE */

SELECT * FROM CLIENTE
WHERE IDCLIENTE = 7;
-- OK É A PAULA É A QUE EU QUERO ATUALIZAR
-- SEMPRE VERIFICAR PRIMEIRO ANTES DE ATUALIZAR OU DELETAR

UPDATE CLIENTE
SET SEXO = 'F'
WHERE IDCLIENTE = 7;

/* DELETE */

INSERT INTO CLIENTE VALUES(NULL,'XXX','M',NULL,'XXX');

SELECT * FROM CLIENTE
WHERE IDCLIENTE = 8;
-- OK É O REGISTRO QUE QUERO DELETAR

DELETE FROM CLIENTE
WHERE IDCLIENTE = 8; 

/* OBS: COMANDOS DML FIM */

/* COMANDOS DE DDL - DATA DEFINITION LANGUAGE */

/* CREATE TABLE, INT, VARCHAR, FLOAT ... */ 
CREATE TABLE PRODUTO(
	IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
	NOME_PRODUTO VARCHAR(30) NOT NULL,
	PRECO INT,
	FRETE FLOAT(10,2) NOT NULL
);

/* ALTER TABLE */

/* ALTERANDO O NOME DE UMA COLUNA - CHANGE */

ALTER TABLE PRODUTO
CHANGE PRECO VALOR_UNITARIO INT NOT NULL;

ALTER TABLE PRODUTO
CHANGE VALOR_UNITARIO VALOR_UNITARIO INT;

/* MODIFY - ALTERANDO O TIPO */

ALTER TABLE PRODUTO
MODIFY VALOR_UNITARIO VARCHAR(50) NOT NULL;

/* ADICIONANDO COLUNAS - ADD */

ALTER TABLE PRODUTO
ADD PESO FLOAT(10,2) NOT NULL;

/* APAGANDO UMA COLUNA - DROP COLUMN */

ALTER TABLE PRODUTO
DROP COLUMN PESO;

/* ADICIONANDO COLUNAS EM ORDEM ESPECIFICA */

ALTER TABLE PRODUTO
ADD COLUMN PESO FLOAT(10,3) NOT NULL
AFTER NOME_PRODUTO;

ALTER TABLE PRODUTO
DROP COLUMN PESO;

ALTER TABLE PRODUTO
ADD COLUMN PESO FLOAT(10,3) NOT NULL
FIRST;

/* OBS: COMANDOS DE DDL FIM */

/* FUNCOES E FUNCAO IFNULL() */

/* NOME. EMAIL, NUMERO, ESTADO */

SELECT C.NOME, C.EMAIL, T.NUMERO, E.ESTADO
FROM  CLIENTE C
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE;

+---------+-------------------+----------+--------+
| JORGE   | jorge@ig.com      | 78458743 | ES     |
| JORGE   | jorge@ig.com      | 56576876 | ES     |
| JOAO    | joao@ig.com       | 87866896 | RJ     |
| CARLOS  | carlos@ig.com     | 54768899 | RJ     |
| JOAO    | joao@ig.com       | 99667587 | RJ     |
| ANA     | ana@ig.com        | 78989765 | SP     |
| ANA     | ana@ig.com        | 99766676 | SP     |
| JOAO    | joao@ig.com       | 66687899 | RJ     |
| JORGE   | jorge@ig.com      | 89986668 | ES     |
| CARLOS  | carlos@ig.com     | 88687909 | RJ     |
| FLAVIO  | FLAVIO@IG.COM     | 68976565 | MG     |
| FLAVIO  | FLAVIO@IG.COM     | 99656675 | MG     |
| GIOVANA | NULL              | 33567765 | RJ     |
| GIOVANA | NULL              | 88668786 | RJ     |
| GIOVANA | NULL              | 55689654 | RJ     |
| KARLA   | KARLA@GMAIL.COM   | 88687979 | RJ     |
| DANIELE | DANIELE@GMAIL.COM | 88965676 | ES     |
| EDUARDO | NULL              | 89966809 | PR     |
| ANTONIO | ANTONIO@IG.COM    | 88679978 | SP     |
| ANTONIO | ANTONIO@UOL.COM   | 99655768 | PR     |
| ELAINE  | ELAINE@GLOBO.COM  | 89955665 | SP     |
| CARMEM  | CARMEM@IG.COM     | 77455786 | RJ     |
| CARMEM  | CARMEM@IG.COM     | 89766554 | RJ     |
| ADRIANA | ADRIANA@GMAIL.COM | 77755785 | RJ     |
| ADRIANA | ADRIANA@GMAIL.COM | 44522578 | RJ     |
| JOICE   | JOICE@GMAIL.COM   | 44522578 | RJ     |
+---------+-------------------+----------+--------+

/* IFNULL() */

SELECT  C.NOME,
		IFNULL(C.EMAIL,'NAO TEM EMAIL'), 
		T.NUMERO, 
		E.ESTADO
FROM  CLIENTE C
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE;

SELECT  C.NOME,
		IFNULL(C.EMAIL,'**********') AS EMAIL, 
		T.NUMERO, 
		E.ESTADO
FROM  CLIENTE C
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE;

/* VIEW */

SELECT  C.NOME,
		C.SEXO,
		C.EMAIL,
		T.TIPO,
		T.NUMERO,
		E.BAIRRO,
		E.CIDADE,
		E.ESTADO
FROM CLIENTE C
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE;

CREATE VIEW RELATORIO AS
	SELECT  C.NOME,
			C.SEXO,
			C.EMAIL,
			T.TIPO,
			T.NUMERO,
			E.BAIRRO,
			E.CIDADE,
			E.ESTADO
	FROM CLIENTE C
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE;

SELECT * FROM RELATORIO;

SHOW VIEWS; -- NAO EXISTE

SHOW TABLES; -- MOSTRA AS VIEWS COMO UMA TABELA VIRTUAL

/* APAGANDO UMA VIEW */

DROP VIEW RELATORIO;

/* INSERINDO UM PREFIXO */

CREATE VIEW V_RELATORIO AS
	SELECT  C.NOME,
			C.SEXO,
			IFNULL(C.EMAIL,'CLIENTE SEM EMAIL') AS 'E-MAIL',
			T.TIPO,
			T.NUMERO,
			E.BAIRRO,
			E.CIDADE,
			E.ESTADO
	FROM CLIENTE C
	INNER JOIN TELEFONE T
	ON C.IDCLIENTE = T.ID_CLIENTE
	INNER JOIN ENDERECO E
	ON C.IDCLIENTE = E.ID_CLIENTE;

/* QUERY EMCIMA DE VIEW */

SELECT NOME, NUMERO, ESTADO
FROM V_RELATORIO;

/* ATÉ AQUI DDL DE VIEW - CREATE, DROP */

/* DML EM VIEWS - SELECT(OK) E OUTROS? */

/* UPDATE, INSERT E DELETE - DML */

INSERT INTO V_RELATORIO VALUES(
'ANDREIA','F','ANDREIA@UOL.COM.BR','CEL','873547864','CENTRO','VITORIA','ES'
);
-- ERROR 1394 (HY000): Can not insert into join view 'COMERCIO.V_RELATORIO' without fields list

DELETE FROM V_RELATORIO
WHERE NOME = 'JORGE';
-- ERROR 1395 (HY000): Can not delete from join view 'COMERCIO.V_RELATORIO'

UPDATE V_RELATORIO
SET NOME = 'JOSE'
WHERE NOME = 'JORGE';
-- !!! É PERMITIDO FAZER UPDATE EM VIEWS COM JOIN !!!

CREATE TABLE JOGADORES(
	IDJOGADOR INT,
	NOME VARCHAR(30),
	ESTADO CHAR(2)
);

INSERT INTO JOGADORES VALUES(1,'GUERRERO','RS');
INSERT INTO JOGADORES VALUES(2,'GABIGOL','RJ');
INSERT INTO JOGADORES VALUES(3,'GANSO','RJ');
INSERT INTO JOGADORES VALUES(4,'NENE','RJ');
INSERT INTO JOGADORES VALUES(5,'LOVE','SP');

CREATE VIEW V_JOGADORES AS
SELECT NOME, ESTADO
FROM JOGADORES;

SELECT * FROM V_JOGADORES;

DELETE FROM V_JOGADORES
WHERE NOME = 'GUERRERO';

INSERT INTO V_JOGADORES VALUES('GUERRERO','RS');

SELECT * FROM JOGADORES;

SELECT * FROM V_RELATORIO
WHERE SEXO = 'F';

/* ORDER BY */

CREATE TABLE ALUNOS(
	NUMERO INT,
	NOME VARCHAR(30)
);

INSERT INTO ALUNOS VALUES(1,'JOAO');
INSERT INTO ALUNOS VALUES(1,'MARIA');
INSERT INTO ALUNOS VALUES(2,'ZOE');
INSERT INTO ALUNOS VALUES(2,'ANDRE');
INSERT INTO ALUNOS VALUES(3,'CLARA');
INSERT INTO ALUNOS VALUES(1,'CLARA');
INSERT INTO ALUNOS VALUES(4,'MAFRA');
INSERT INTO ALUNOS VALUES(5,'JANAINA');
INSERT INTO ALUNOS VALUES(1,'JANAINA');
INSERT INTO ALUNOS VALUES(3,'MARCELO');
INSERT INTO ALUNOS VALUES(4,'GIOVANI');
INSERT INTO ALUNOS VALUES(5,'ANTONIO');
INSERT INTO ALUNOS VALUES(6,'ANA');
INSERT INTO ALUNOS VALUES(6,'VIVIANE');

SELECT * FROM ALUNOS
ORDER BY NUMERO;

SELECT * FROM ALUNOS
ORDER BY 1;

SELECT * FROM ALUNOS
ORDER BY 2;

/* ORDENANDO POR MAIS DE UMA COLUNA */

SELECT * FROM ALUNOS
ORDER BY NUMERO, NOME; 

SELECT * FROM ALUNOS
ORDER BY 1, 2; 

/* MESCLANDO ORDER BY COM PROJECAO */

SELECT NOME FROM ALUNOS
ORDER BY 1, 2;
-- ERROR 1054 (42S22): Unknown column '2' in 'order clause'

SELECT NOME FROM ALUNOS
ORDER BY NUMERO, NOME; 

/* ORDER BY DESC / ASC */

SELECT * FROM ALUNOS
ORDER BY 1 ASC; 

SELECT * FROM ALUNOS
ORDER BY 1 DESC; 

SELECT * FROM ALUNOS
ORDER BY 1, 2 DESC; 

SELECT * FROM ALUNOS
ORDER BY 1 DESC, 2 DESC; 

/* ORDENANDO COM JOIN */

SELECT  C.NOME,
		C.SEXO,
		IFNULL(C.EMAIL,'CLIENTE SEM EMAIL') AS 'E-MAIL',
		T.TIPO,
		T.NUMERO,
		E.BAIRRO,
		E.CIDADE,
		E.ESTADO
FROM CLIENTE C
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE
ORDER BY 1;

SHOW TABLES;

SELECT * FROM V_RELATORIO
ORDER BY 1;

/* DELIMITADOR */

-- DELIMITADOR PADRAO -> ;

SELECT  C.NOME,
		C.SEXO,
		IFNULL(C.EMAIL,'CLIENTE SEM EMAIL') AS 'E-MAIL',
		T.TIPO,
		T.NUMERO,
		E.BAIRRO,
		E.CIDADE,
		E.ESTADO
FROM CLIENTE C
INNER JOIN TELEFONE T
ON C.IDCLIENTE = T.ID_CLIENTE
INNER JOIN ENDERECO E
ON C.IDCLIENTE = E.ID_CLIENTE
ORDER BY 1
-- SEM DELIMITADOR -> ;

STATUS
-- NÃO PRECISA DE DELIMITADOR

/* PODEMOS MUDAR O DELIMITADOR PARA PROGRAMAR EM SQL É NECESSÁRIO */

DELIMITER $

SELECT * FROM V_RELATORIO;

DELIMITER  @
-- COM DOIS ESPACOS COME O ESPAÇO A MAIS E FUNCIONA

DELIMITER@
-- ERRO

DELIMITER @ @
-- FUNCIONA COM UM @ SÓ

/* DELIMITER É UM CARACTER SÓ */

DELIMITER ;
-- VOLTANDO O PADRAO

/* STORED PROCEDURES */

SELECT 'MAFRA';

DELIMITER $

/* SINTAXE PADRAO - CRIAR PROCEDURE */

CREATE PROCEDURE NOME()
BEGIN
	
	QUALQUER PROGRAMACAO;

END
$

DELIMITER $

CREATE PROCEDURE NOME_EMPRESA()
BEGIN
	
	SELECT 'UNIVERSIDADE DOS DADOS' AS EMPRESA;

END
$

/* CHAMANDO UMA PROCEDURE */

CALL NOME_EMPRESA()$

DELIMITER ;

CALL NOME_EMPRESA();

/* PROCEDURES COM PARAMETROS */

SELECT 10 + 10 AS CONTA;

DELIMITER $

CREATE PROCEDURE CONTA()
BEGIN

	SELECT 10 + 10 AS CONTA;

END
$

DELIMITER ;

DROP PROCEDURE CONTA;
-- DELETANDO PROCEDURE

DELIMITER $

CREATE PROCEDURE CONTA(NUMERO1 INT, NUMERO2 INT)
BEGIN

	SELECT NUMERO1 + NUMERO2 AS CONTA;

END
$

DELIMITER ;

CALL CONTA(100,50);

/* PROCEDURES NA VIDA REAL */

CREATE DATABASE PROJETO2;

USE PROJETO2;

DROP DATABASE PROJETO2;
--USAREI A PROJETO MESMO!!

USE PROJETO;

CREATE TABLE CURSOS(
	IDCURSO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30) NOT NULL,
	HORAS INT(3) NOT NULL,
	VALOR FLOAT(10,2) NOT NULL
);

INSERT INTO CURSOS VALUES(NULL,'JAVA',30,500.00);
INSERT INTO CURSOS VALUES(NULL,'FUNDAMENTOS DE BANCO DE DADOS',40,700.00);

SELECT * FROM CURSOS;

DELIMITER #

STATUS

CREATE PROCEDURE CAD_CURSO (P_NOME VARCHAR(30),
							P_HORAS INT(3),
							P_VALOR FLOAT(10,2))
BEGIN

	INSERT INTO CURSOS VALUES(NULL,P_NOME,P_HORAS,P_VALOR);

END
#

DELIMITER ;

CALL CAD_CURSO('BI SQL SERVER',35,3000.00);
CALL CAD_CURSO('POWER BI SQL SERVER',20,1000.00);
CALL CAD_CURSO('TABLEAU',30,1200.00);

SELECT * FROM CURSOS;

/* CRIAR UMA PROCEDURE PARA CONSULTAR CURSOS */

DELIMITER $

CREATE PROCEDURE SEL_CURSO()
BEGIN

	SELECT IDCURSO, NOME, HORAS, VALOR FROM CURSOS;

END
$

DELIMITER ;

CALL SEL_CURSO();

/* FUNÇÃO DE AGREGACAO NUMERICAS */

CREATE TABLE VENDEDORES(
	IDVENDEDOR INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	SEXO CHAR(1),
	JANEIRO FLOAT(10,2),
	FEVEREIRO FLOAT(10,2),
	MARCO FLOAT(10,2)
);

INSERT INTO VENDEDORES VALUES(NULL,'CARLOS','M',76234.78,88346.87,5756.90);
INSERT INTO VENDEDORES VALUES(NULL,'MARIA','F',5865.78,6768.87,4467.90);
INSERT INTO VENDEDORES VALUES(NULL,'ANTONIO','M',78769.78,6685.87,6664.90);
INSERT INTO VENDEDORES VALUES(NULL,'CLARA','F',5779.78,446886.87,8965.90);
INSERT INTO VENDEDORES VALUES(NULL,'ANDERSON','M',676545.78,77544.87,578665.90);
INSERT INTO VENDEDORES VALUES(NULL,'IVONE','F',57789.78,44774.87,68665.90);
INSERT INTO VENDEDORES VALUES(NULL,'JOAO','M',4785.78,66478.87,6887.90);
INSERT INTO VENDEDORES VALUES(NULL,'CELIA','F',89667.78,57654.87,5755.90);

/* MAX - TRAZ O VALOR MAXIMO DE UMA COLUNA */

SELECT MAX(FEVEREIRO) AS MAIOR_FEV
FROM VENDEDORES;

/* MIN - TRAZ O VALOR MINIMO DE UMA COLUNA */

SELECT MIN(FEVEREIRO) AS MENOR_FEV
FROM VENDEDORES;

/* AVG - TRAZ O VALOR MEDIO DE UMA COLUNA */

SELECT AVG(FEVEREIRO) AS MEDIA_FEV
FROM VENDEDORES;

/* VARIAS FUNCOES */

SELECT 	MAX(JANEIRO) AS MAX_JAN,
		MIN(JANEIRO) AS MIN_JAN,
		AVG(JANEIRO) AS MEDIA_JAN
FROM VENDEDORES;

/* TRUNCATE */

SELECT 	MAX(JANEIRO) AS MAX_JAN,
		MIN(JANEIRO) AS MIN_JAN,
		TRUNCATE(AVG(JANEIRO),2) AS MEDIA_JAN
FROM VENDEDORES;

/* AGREGANDO COM SUM() */

SELECT SUM(JANEIRO) AS TOTAL_JAN
FROM VENDEDORES;

SELECT 	SUM(JANEIRO) AS TOTAL_JAN,
		SUM(FEVEREIRO) AS TOTAL_FEV,
		SUM(MARCO) AS TOTAL_MAR
FROM VENDEDORES;

/* VENDAR POR SEXO */

SELECT SEXO, SUM(MARCO) AS TOTAL_MARCO
FROM VENDEDORES
GROUP BY SEXO;

/* SUBQUERIES */

/* VENDEDOR QUE VENDEU MENOS EM MARCO E SEU NOME */

SELECT NOME, MIN(MARCO) AS MIN_MARCO
FROM VENDEDORES;
-- NAO FUNCIONA

SELECT NOME, MARCO AS VALOR,
FROM VENDEDORES
WHERE MARCO = MIN(MARCO);
-- NAO FUNCIONA

SELECT MARCO AS VALOR, NOME
FROM VENDEDORES
WHERE MARCO = SELECT MIN(MARCO) FROM VENDEDORES;
-- NAO FUNCIONA

SELECT MIN(MARCO) FROM VENDEDORES;
-- MINIMO DE MARCO

SELECT NOME, MARCO AS VALOR FROM VENDEDORES
WHERE MARCO = (SELECT MIN(MARCO) FROM VENDEDORES);
-- OK FUNCIONOU

/* NOME E VALOR QUE VENDEU MAIS */

SELECT NOME, MARCO AS VALOR FROM VENDEDORES
WHERE MARCO = (SELECT MAX(MARCO) FROM VENDEDORES);


/* NOMES QUE VENDERAM ACIMA DA MEDIA EM FEV */

SELECT NOME, FEVEREIRO AS VALOR FROM VENDEDORES
WHERE FEVEREIRO > (SELECT AVG(FEVEREIRO) FROM VENDEDORES);

SELECT AVG(FEVEREIRO) FROM VENDEDORES;

SELECT NOME, FEVEREIRO AS VALOR FROM VENDEDORES
WHERE FEVEREIRO < (SELECT AVG(FEVEREIRO) FROM VENDEDORES);

SELECT NOME, JANEIRO AS VALOR FROM VENDEDORES
WHERE JANEIRO > (SELECT AVG(JANEIRO) FROM VENDEDORES);

/* OPERACOES EM LINHA */

SELECT * FROM VENDEDORES;

SELECT  NOME,
		SEXO,
		JANEIRO,
		FEVEREIRO,
		MARCO,
		(JANEIRO+FEVEREIRO+MARCO) AS 'TOTAL_TRIMESTRE',
		TRUNCATE((JANEIRO+FEVEREIRO+MARCO)/3,2) AS 'MEDIA'
FROM VENDEDORES;

/* APLICANDO UMA PORCENTAGEM (%) */

SELECT  NOME,
		SEXO,
		JANEIRO,
		FEVEREIRO,
		MARCO,
		(JANEIRO+FEVEREIRO+MARCO) AS 'TOTAL_TRIMESTRE',
		(JANEIRO+FEVEREIRO+MARCO) * .25 AS 'DESCONTO(25%)',
		TRUNCATE((JANEIRO+FEVEREIRO+MARCO)/3,2) AS 'MEDIA'
FROM VENDEDORES;

/* ALTERANDO TABELAS */

CREATE TABLE TABELA(
	COLUNA1 VARCHAR(30),
	COLUNA2 VARCHAR(30),
	COLUNA3 VARCHAR(30)
);

-- ADICIONANDO UMA PRIMARY KEY PK 
ALTER TABLE TABELA
ADD PRIMARY KEY (COLUNA1);

DESC TABELA;

-- ADICIONANDO UMA COLUNA SEM POSICAO, ULTIMA POSICAO
ALTER TABLE TABELA
ADD COLUNA VARCHAR(30);

ALTER TABLE TABELA
ADD COLUNA100 INT;

-- ADICIONANDO UMA COLUNA COM POSICAO
ALTER TABLE TABELA
ADD COLUNA4 VARCHAR(30) NOT NULL UNIQUE
AFTER COLUNA3;

-- MODIFICANDO O TIPO DE UM CAMPO
ALTER TABLE TABELA
MODIFY COLUNA2 DATE NOT NULL;

-- RENOMEANDO O NOME DA TABELA
ALTER TABLE TABELA
RENAME PESSOA;

CREATE TABLE TIME(
	IDTIME INT PRIMARY KEY AUTO_INCREMENT,
	TIME VARCHAR(30),
	ID_PESSOA VARCHAR(30)
);

-- ADICIONANDO FOREIGN KEY (CHAVE ESTRANGEIRA) A UMA COLUNA EXISTENTE
ALTER TABLE TIME
ADD FOREIGN KEY(ID_PESSOA)
REFERENCES PESSOA(COLUNA1);

/* VERIFICAR AS CHAVES */
SHOW CREATE TABLE TIME;

/* ORGANIZACAO DE CHAVES - CONSTRAINT (REGRA) */

CREATE TABLE JOGADOR(
	IDJOGAODR INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30)
);

CREATE TABLE TIMES(
	IDTIME INT PRIMARY KEY AUTO_INCREMENT,
	NOMETIME VARCHAR(30),
	ID_JOGADOR INT,
	FOREIGN KEY(ID_JOGADOR)
	REFERENCES JOGADOR(IDJOGAODR)
);

INSERT INTO JOGADOR VALUES(NULL, 'GUERRERO');
INSERT INTO TIMES VALUES(NULL,'FLAMENGO',1);

SELECT * FROM JOGADOR;

SELECT * FROM TIMES;

SHOW CREATE TABLE JOGADOR;

SHOW CREATE TABLE TIMES;

/* ORGANIZANDO CHAVES E ACOES DE CONSTRAINTS */

SHOW TABLES;

DROP TABLE ENDERECO;
DROP TABLE TELEFONE;
DROP TABLE CLIENTE;
-- NÃO IREI DAR OS COMANDOS ACIMA
-- AO INVES CRIAREI TABELAS COM PREFIXO T

USE COMERCIO;

CREATE TABLE TCLIENTE(
	IDCLIENTE INT,
	NOME VARCHAR(30) NOT NULL
);

CREATE TABLE TTELEFONE(
	IDTELEFONE INT,
	TIPO CHAR(3) NOT NULL,
	NUMERO VARCHAR(10) NOT NULL,
	ID_CLIENTE INT
);

ALTER TABLE TCLIENTE ADD CONSTRAINT PK_TCLIENTE
PRIMARY KEY(IDCLIENTE);

ALTER TABLE TTELEFONE ADD CONSTRAINT FK_TCLIENTE_TTELEFONE
FOREIGN KEY(ID_CLIENTE) REFERENCES TCLIENTE(IDCLIENTE);

SHOW CREATE TABLE TTELEFONE;

/* DICIONARIO DE DADOS */

SHOW DATABASES;

USE information_schema;

STATUS

SHOW TABLES;

DESC TABLE_CONSTRAINTS;

SELECT  CONSTRAINT_SCHEMA AS 'BANCO',
		TABLE_NAME AS 'TABELA',
		CONSTRAINT_NAME AS 'NOME REGRA',
		CONSTRAINT_TYPE AS 'TIPO'
		FROM TABLE_CONSTRAINTS
		WHERE CONSTRAINT_SCHEMA = 'COMERCIO';

/* APAGANDO CONSTRAINTS */

USE COMERCIO;

ALTER TABLE TTELEFONE
DROP FOREIGN KEY FK_TCLIENTE_TTELEFONE;

ALTER TABLE TTELEFONE ADD CONSTRAINT FK_TCLIENTE_TTELEFONE
FOREIGN KEY(ID_CLIENTE) REFERENCES TCLIENTE(IDCLIENTE);

/* ACOES DE CONSTRAINTS */
???

/* TRIGGERS */

/* ENTENDENDO */

/* ESTRUTURA DE UMA TRIGGER */

DELIMITER $

CREATE TRIGGER NOME
BEFORE/AFTER INSERT/DELETE/UPDATE ON TABELA
FOR EACH ROW (PARA CADA LINHA)
BEGIN -> INICIO

	QUALQUER COMANDO SQL

END -> FIM
$

DELIMITER ;

/* USANDO TRIGGERS */

CREATE DATABASE AULA80;

USE AULA80;

CREATE TABLE USUARIO(
	IDUSUARIO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	LOGIN VARCHAR(30),
	SENHA VARCHAR(100)
);

CREATE TABLE BKP_USUARIO(
	IDBACKUP INT PRIMARY KEY AUTO_INCREMENT,
	IDUSUARIO INT,
	NOME VARCHAR(30),
	LOGIN VARCHAR(30)
);

DELIMITER $

CREATE TRIGGER BACKUP_USER
BEFORE DELETE ON USUARIO
FOR EACH ROW
BEGIN

	INSERT INTO BKP_USUARIO VALUES(NULL,OLD.IDUSUARIO,OLD.NOME,OLD.LOGIN);
	
END
$

DELIMITER ;

INSERT INTO USUARIO VALUES(NULL,'ANDRADE','ANDRADE2009','HEXACAMPEAO');

SELECT * FROM USUARIO;

DELETE FROM USUARIO
WHERE IDUSUARIO = 1;

SELECT * FROM BKP_USUARIO;

SELECT * FROM USUARIO;

/* COMUNICACAO ENTRE BANCOS DE DADOS */

CREATE DATABASE LOJA;

USE LOJA;

CREATE TABLE PRODUTO(
	IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	VALOR FLOAT(10,2)
);

STATUS

CREATE DATABASE BACKUP;

USE BACKUP;

STATUS

CREATE TABLE BKP_PRODUTO(
	IDBKP INT PRIMARY KEY AUTO_INCREMENT,
	IDPRODUTO INT,
	NOME VARCHAR(30),
	VALOR FLOAT(10,2)
);

USE LOJA;

INSERT INTO BACKUP.BKP_PRODUTO VALUES(NULL,1000,'TESTE',0.00);

SELECT * FROM BACKUP.BKP_PRODUTO;

DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO
BEFORE INSERT ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO
	VALUES(NULL,NEW.IDPRODUTO,NEW.NOME,NEW.VALOR);
END
$

DELIMITER ;

INSERT INTO PRODUTO VALUES(NULL,'LIVRO MODELAGEM',50.00);
INSERT INTO PRODUTO VALUES(NULL,'LIVRO BI',80.00);
INSERT INTO PRODUTO VALUES(NULL,'LIVRO ORACLE',70.00);
INSERT INTO PRODUTO VALUES(NULL,'LIVRO SQL SERVER',100.00);

SELECT * FROM PRODUTO;

SELECT * FROM BACKUP.BKP_PRODUTO;

DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO_DEL
BEFORE DELETE ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO
	VALUES(NULL,OLD.IDPRODUTO,OLD.NOME,OLD.VALOR);
END
$

DELIMITER ;

DELETE FROM PRODUTO
WHERE IDPRODUTO = 2;

SELECT * FROM PRODUTO;

SELECT * FROM BACKUP.BKP_PRODUTO;

DROP TRIGGER BACKUP_PRODUTO;

DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO
AFTER INSERT ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO
	VALUES(NULL,NEW.IDPRODUTO,NEW.NOME,NEW.VALOR);
END
$

DELIMITER ;

INSERT INTO PRODUTO VALUES(NULL,'LIVRO C#',100.00);

SELECT * FROM PRODUTO;

SELECT * FROM BACKUP.BKP_PRODUTO;

/* MELHORANDO O BACKUP */

ALTER TABLE BACKUP.BKP_PRODUTO
ADD EVENTO CHAR(1);

SELECT * FROM BACKUP.BKP_PRODUTO;

DROP TRIGGER BACKUP_PRODUTO_DEL;

DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO_DEL
BEFORE DELETE ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO
	VALUES(NULL,OLD.IDPRODUTO,OLD.NOME,OLD.VALOR,'D');
END
$

DELIMITER ;

DELETE FROM PRODUTO
WHERE IDPRODUTO = 4;

SELECT * FROM PRODUTO;

SELECT * FROM BACKUP.BKP_PRODUTO;

DROP TRIGGER BACKUP_PRODUTO;

DELIMITER $

CREATE TRIGGER BACKUP_PRODUTO
AFTER INSERT ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP.BKP_PRODUTO
	VALUES(NULL,NEW.IDPRODUTO,NEW.NOME,NEW.VALOR,'I');
END
$

DELIMITER ;

INSERT INTO PRODUTO VALUES(NULL,'LIVRO INSERT SQL',1.00);

SELECT * FROM PRODUTO;

SELECT * FROM BACKUP.BKP_PRODUTO;

/* TRIGGER DE AUDITORIA */

DROP DATABASE LOJA;

DROP DATABASE BACKUP;

-- NAO QUERO TAZER OS DROPS
-- USAREI COM SUFIXO 2

CREATE DATABASE LOJA2;

USE LOJA2;

CREATE TABLE PRODUTO(
	IDPRODUTO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	VALOR FLOAT(10,2)
);

INSERT INTO PRODUTO VALUES(NULL,'LIVRO MODELAGEM',50.00);
INSERT INTO PRODUTO VALUES(NULL,'LIVRO BI',80.00);
INSERT INTO PRODUTO VALUES(NULL,'LIVRO ORACLE',70.00);
INSERT INTO PRODUTO VALUES(NULL,'LIVRO SQL SERVER',100.00);

CREATE DATABASE BACKUP2;

USE BACKUP2;

-- QUANDO
SELECT NOw();

-- QUEM
SELECT CURRENT_USER();

CREATE TABLE BKP_PRODUTO(
	IDBACKUP INT PRIMARY KEY AUTO_INCREMENT,
	IDPRODUTO INT,
	NOME VARCHAR(30),
	VALOR_ORIGINAL FLOAT(10,2),
	VALOR_ALTERADO FLOAT(10,2),
	DATA DATETIME,
	USUARIO VARCHAR(30),
	EVENTO CHAR(1)
);

USE LOJA2;

SELECT * FROM PRODUTO;

DELIMITER $

CREATE TRIGGER AUDIT_PROD
AFTER UPDATE ON PRODUTO
FOR EACH ROW
BEGIN
	INSERT INTO BACKUP2.BKP_PRODUTO 
	VALUES(NULL,OLD.IDPRODUTO,OLD.NOME,OLD.VALOR,NEW.VALOR,NOW(),CURRENT_USER(),'U');
END
$

DELIMITER ;

UPDATE PRODUTO
SET VALOR = 110.00
WHERE IDPRODUTO = 4;

SELECT * FROM PRODUTO;

SELECT * FROM BACKUP2.BKP_PRODUTO;

/* AUTORELACIONAMENTO */

CREATE DATABASE AULA84;

USE AULA84;

CREATE TABLE CURSOS(
	IDCURSO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	HORAS INT,
	VALOR FLOAT(10,2),
	ID_PREREQ INT
);

ALTER TABLE CURSOS
ADD CONSTRAINT FK_PREREQ
FOREIGN KEY(ID_PREREQ)
REFERENCES CURSOS(IDCURSO);

INSERT INTO CURSOS VALUES(NULL,'BD RELACIONAL',20,400.00,NULL);
INSERT INTO CURSOS VALUES(NULL,'BUSINESS INTELLIGENCE',40,800.00,1);
INSERT INTO CURSOS VALUES(NULL,'RELATORIOS AVANCADOS',20,600.00,2);
INSERT INTO CURSOS VALUES(NULL,'LOGICA DE PROGRAMACAO',20,400.00,NULL);
INSERT INTO CURSOS VALUES(NULL,'RUBY',30,500.00,4);

SELECT * FROM CURSOS;

SELECT NOME, VALOR, HORAS, IFNULL(ID_PREREQ,"SEM REQ") REQUISITO
FROM CURSOS;

/* EXERCICIO MOSTRAR O NOME DO PRE REQUISITO DO ACIMA */

SELECT  C.NOME AS CURSO,
		C.VALOR AS VALOR,
		C.HORAS AS CARGA,
		IFNULL(P.NOME,"---") AS PREREQUISITO
FROM CURSOS C
LEFT JOIN CURSOS P
ON P.IDCURSO = C.ID_PREREQ;

/* CURSORES */

CREATE DATABASE CURSORES;

USE CURSORES;

CREATE TABLE VENDEDORES(
	IDVENDEDOR INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(50),
	JAN INT,
	FEV INT,
	MAR INT
);

INSERT INTO VENDEDORES VALUES(NULL,'MAFRA',32432,242334,574545);
INSERT INTO VENDEDORES VALUES(NULL,'CLARA',65465,65443,65454);
INSERT INTO VENDEDORES VALUES(NULL,'JOAO',12432,65356,8756);
INSERT INTO VENDEDORES VALUES(NULL,'LILIAN',4567,9676,8765);
INSERT INTO VENDEDORES VALUES(NULL,'ANTONIO',3467,68756,99765);
INSERT INTO VENDEDORES VALUES(NULL,'GLORIA',54786,76889,07098);

SELECT * FROM VENDEDORES;

SELECT NOME, (JAN+FEV+MAR) AS TOTAL FROM VENDEDORES;

SELECT NOME, (JAN+FEV+MAR) AS TOTAL, TRUNCATE((JAN+FEV+MAR)/3,2) AS MEDIA FROM VENDEDORES;

CREATE TABLE VEND_TOTAL(
	NOME VARCHAR(50),
	JAN INT,
	FEV INT,
	MAR INT,
	TOTAL INT,
	MEDIA INT
);

DELIMITER $

CREATE PROCEDURE INSEREDADOS()
BEGIN
	DECLARE FIM INT DEFAULT 0;
	DECLARE VAR1, VAR2, VAR3, VTOTAL, VMEDIA INT;
	DECLARE VNOME VARCHAR(50);

	DECLARE REG CURSOR FOR(
		SELECT NOME, JAN, FEV, MAR FROM VENDEDORES
	);

	DECLARE CONTINUE HANDLER FOR NOT FOUND SET FIM = 1;

	OPEN REG;

	REPEAT

		FETCH REG INTO VNOME, VAR1, VAR2, VAR3;
		IF NOT FIM THEN

			SET VTOTAL = VAR1 + VAR2 + VAR3;
			SET VMEDIA = VTOTAL / 3;

			INSERT INTO VEND_TOTAL
			VALUES(VNOME,VAR1,VAR2,VAR3,VTOTAL,VMEDIA);
		END IF;

	UNTIL FIM END REPEAT;

	CLOSE REG;

END
$

DELIMITER ;

SELECT * FROM VENDEDORES;

SELECT * FROM VEND_TOTAL;

CALL INSEREDADOS();

SELECT * FROM VEND_TOTAL;

/* SEGUNDA E TERCEIRA FORMAS NORMAIS */

/*  
	PRIMEIRA FN
	
	A - ATOMICIDADE - UM CAMPO NAO PODE SER DIVISIVEL,
	B - UM CAMPO NAO PODE SER VETORIZADO,
	C - PK CHAVE PRIMARIA.

	SEGUNDA FN (DEPENDENCIA DIRETA)

	- CAMPOS NÃO CHAVES (NOT KEYS) TEM QUE DEPENDER DIRETAMENTE DE
	  TODAS AS CHAVES (OU CAMPOS ASSOCIATIVOS) SIMULTANEAMENTE.

	TERCEIRA FN (DEPENDENCIA TRANSITIVA)

	- CAMPOS NÃO CHAVES QUE DEPENDEM DE OUTRO(S) CAMPO(S) NÃO CHAVE
	  TEM QUE IR PARA OUTRA TABELA.

*/

CREATE DATABASE CONSULTORIO;

USE CONSULTORIO;

CREATE TABLE PACIENTE(
	IDPACIENTE INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	SEXO CHAR(1),
	EMAIL VARCHAR(30),
	NASCIMENTO DATE
);

CREATE TABLE MEDICO(
	IDMEDICO INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	SEXO CHAR(1),
	ESPECIALIDADE VARCHAR(30),
	FUNCIONARIO ENUM('S','N')
);

CREATE TABLE HOSPITAL(
	IDHOSPITAL INT PRIMARY KEY AUTO_INCREMENT,
	NOME VARCHAR(30),
	BAIRRO VARCHAR(30),
	CIDADE VARCHAR(30),
	ESTADO CHAR(2)
);

CREATE TABLE CONSULTA(
	IDCONSULTA INT PRIMARY KEY AUTO_INCREMENT,
	ID_PACIENTE INT,
	ID_MEDICO INT,
	ID_HOSPITAL INT,
	DATA DATETIME,
	DIAGNOSTICO VARCHAR(50)
);

CREATE TABLE INTERNACAO(
	IDINTERNACAO INT PRIMARY KEY AUTO_INCREMENT,
	ENTRADA DATETIME,
	QUARTO INT,
	SAIDA DATETIME,
	OBSERVACOES VARCHAR(50),
	ID_CONSULTA INT UNIQUE
);

-- CONSTRAINTS

ALTER TABLE CONSULTA
ADD CONSTRAINT FK_CONSULTA_PACIENTE
FOREIGN KEY (ID_PACIENTE)
REFERENCES PACIENTE(IDPACIENTE);

ALTER TABLE CONSULTA
ADD CONSTRAINT FK_CONSULTA_MEDICO
FOREIGN KEY (ID_MEDICO)
REFERENCES MEDICO(IDMEDICO);

ALTER TABLE CONSULTA
ADD CONSTRAINT FK_CONSULTA_HOSPITAL
FOREIGN KEY (ID_HOSPITAL)
REFERENCES HOSPITAL(IDHOSPITAL);

ALTER TABLE INTERNACAO
ADD CONSTRAINT FK_INTERNACAO_CONSULTA
FOREIGN KEY (ID_CONSULTA)
REFERENCES CONSULTA(IDCONSULTA);

SHOW DATABASES;

SHOW TABLES;

DESC TABLE_CONSTRAINTS;

SELECT * FROM TABLE_CONSTRAINTS WHERE CONSTRAINT_SCHEMA = 'CONSULTORIO';
